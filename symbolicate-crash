#!/usr/bin/python
from __future__ import print_function

def symbolicate_crash_cmd(args):
    crash_lines = open(args.dotcrash, "r").readlines()

    import collections, os, os.path, re, subprocess, sys

    #
    # enumerate binary images in the crash
    binaries = {}
    BinaryInfo = collections.namedtuple('BinaryInfo', ["start_hex", "end_hex", "name", "uuid", "path"])
    i = 0
    while (i < len(crash_lines)):
        if re.search(r'''\s*Binary Images:''', crash_lines[i]):
            i += 1
            break
        i += 1
    while (i < len(crash_lines)):
        rxm = re.search(r'''\s* ( 0x[0-9a-fA-F]+ ) \s* - \s* ( 0x[0-9a-fA-F]+ | \?\?\? ) \s+ \+?(\S+) .* <([0-9a-fA-F\-]+)> \s+ ([^\n\r\t]*)''', crash_lines[i], flags=re.X)
        if not rxm:
            break
        start_hex, end_hex, name, uuid, path = rxm.groups()
        uuid = uuid.upper()
        if name == "???":
            name = uuid.upper()
        if args.verbose:
            print("Binary Image: {} <{}> [{} ..< {}]".format(name, uuid, start_hex, end_hex), file=sys.stderr)
        info = BinaryInfo(start_hex=start_hex, end_hex=end_hex, name=name, uuid=uuid, path=path)
        binaries[name] = info
        i += 1

    #
    # `end_hex` may be ??? sometimes. Resolve it by using next image's address as end_hex
    start_hex_and_name_list = [(int(binaries[name].start_hex, 16), name) for name in binaries]
    start_hex_and_name_list.sort()
    for name in binaries:
        if binaries[name].end_hex == "???":
            pos = start_hex_and_name_list.index( (int(binaries[name].start_hex, 16), name) )
            if pos < len(start_hex_and_name_list)-1:
                fixed_end_hex = hex(start_hex_and_name_list[pos+1][0])
            else:
                fixed_end_hex = "0x7fffffffffffffff"
            binaries[name] = BinaryInfo(start_hex=binaries[name].start_hex, end_hex=fixed_end_hex, name=name, uuid=binaries[name].uuid, path=binaries[name].path)
            if args.verbose:
                print("Fixed end address: {} -> {}".format(name, fixed_end_hex), file=sys.stderr)

    #
    # in case executable basename appears instead of bundle id (e.g. "Application Specific Backtrace" sections)
    binary_by_basename = { os.path.basename(binary.path) : binary for binary in binaries.values() }
    for basename in binary_by_basename:
        if basename not in binaries:
            binaries[basename] = binary_by_basename[basename]

    #
    # enumerate dsyms
    dsyms = {}
    dirs = args.symdirs if args.symdirs else ["."]
    for dsymdir in dirs:
        for fn in os.listdir(dsymdir):
            if not fn.endswith(".dSYM"):
                continue
            path = os.path.join(dsymdir, fn)
            try:
                output = subprocess.check_output(["dwarfdump", "--uuid", path], universal_newlines=True)
                rxm = re.search(r'''UUID: \s+ ([0-9a-fA-F\-]+) \s+ \(\S+\) \s+ ([^\n\r\t]+)''', output, flags=re.X)
                uuid, binpath = rxm.groups()
                dsyms[uuid.upper()] = binpath
            except subprocess.CalledProcessError, ex:
                print("dwarfdump failed: {}".format(path), file=sys.stderr)
    assert dsyms, "no .dSYM files found in directories: {}".format(dirs)

    #
    # find lines with unresolved symbols and plan atos calls
    atos_calls = {}
    AtosAddress = collections.namedtuple("AtosAddress", ["hexaddr", "index", "needle"])
    failed_binaries = {}
    for i in range(len(crash_lines)):
        # example (crash report): 1   libguimodel.dylib                0x006ee72a 0x64d000 + 661290
        rxm = re.search(r'''^\d+ \s+ (\S+) \s+ (0x[0-9a-fA-F]+) \s+ ([^\n\r\t]+)''', crash_lines[i], flags=re.X)
        if rxm:
            name, hexaddr, needle = rxm.groups()
            if name in failed_binaries:
                continue
            if (name in binaries) and (binaries[name].uuid in dsyms):
                if name in atos_calls:
                    atos_addresses = atos_calls[name]
                else:
                    atos_addresses = []
                    atos_calls[name] = atos_addresses
                atos_addresses.append(AtosAddress(hexaddr=hexaddr, index=i, needle=needle))
            else:
                # Check if dsym is found, but uuids do not match.
                fn = os.path.basename(binaries[name].path if (name in binaries) else name)
                for dsympath in dsyms.values():
                    if os.path.basename(dsympath) == fn:
                        failed_binaries[name] = "binary and dSYM are from different builds ('{}' has different UUID from '{}')".format(binaries[name].path, dsympath)
                        break
                else:
                    # for-else is executed when `for` was not terminated by `break`

                    # non-symbolicated lines are expected to be like this
                    # 0   CoreFoundation                      0x910eb343 0xXXXXXXXX + 195
                    # 0   CoreFoundation                      0x910eb343 _MangledName + 195
                    if needle.startswith(name + ' + '):
                        failed_binaries[name] = "no symbols found"
            continue
        # example (hang report):           53  ??? (libkl_service.dylib + 429367) [0x2dd4d37] 1-53
        rxm = re.search(r'''\s+ \*?\d+ \s+ (.*) \s \[0[xX]([a-fA-F0-9]+)\]''', crash_lines[i], flags=re.X)
        if rxm:
            needle, hexaddr = rxm.groups()
            laddr = int(hexaddr,16)
            for binary in binaries.values():
                #if laddr >= int(binary.start_hex, 16) and laddr < int(binary.end_hex, 16):
                #    print(binary, binary.uuid in dsyms)
                if laddr >= int(binary.start_hex, 16) and laddr < int(binary.end_hex, 16) and binary.uuid in dsyms:
                    if binary.name in atos_calls:
                        atos_addresses = atos_calls[binary.name]
                    else:
                        atos_addresses = []
                        atos_calls[binary.name] = atos_addresses
                    atos_addresses.append(AtosAddress(hexaddr=hexaddr, index=i, needle=needle))
                    break

    #
    # make atos calls and substitute lines in the report
    replacements_made = False
    for name in atos_calls:
        load_hex = binaries[name].start_hex
        dwarf_path = dsyms[binaries[name].uuid]
        atos_addresses = atos_calls[name]
        hexes = [addr.hexaddr for addr in atos_addresses]
        try:
            inv_args = ["atos", "-l", load_hex, "-o", dwarf_path] + hexes
            output = subprocess.check_output(inv_args, universal_newlines=True)
        except subprocess.CalledProcessError, ex:
            failed_binaries[name] = "atos failed"
        output_lines = output.splitlines()
        if len(output_lines) < len(atos_addresses):
            failed_binaries[name] = "atos produced strange output (unknown version?)"
        else:
            for i in range(len(atos_addresses)):
                addr = atos_addresses[i]
                line = crash_lines[addr.index].replace(addr.needle, output_lines[i])
                if line != crash_lines[addr.index]:
                    crash_lines[addr.index] = line
                    replacements_made = True

    #
    # output the result
    if replacements_made or not failed_binaries:
        exit_code = 0
        if args.rewrite:
            open(args.dotcrash, "w").write("".join(crash_lines))
        else:
            for line in crash_lines:
                print(line, end="") # newlines are already there for the original file
    else:
        exit_code = 1

    #
    # print warnings
    for name in failed_binaries:
        print("{}: {}".format(name, failed_binaries[name]), file=sys.stderr)

    raise SystemExit(exit_code)

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("-d", "--symdirs", action="append", metavar="dsymdir", help="Directory with .dSYM bundles, may appear multiple times. If absent, the current working directory will be used.")
    parser.add_argument("-w", "--rewrite", action="store_true", help="Rewrite crash file inplace, instead of printing symbolicated result to stdout.")
    parser.add_argument("dotcrash", help="A crash file to symbolicate.")
    parser.add_argument("-v", "--verbose", action="store_true")
    parser.add_argument("--version", action="version", version="%(prog)s 0.6.2")
    args = parser.parse_args()
    symbolicate_crash_cmd(args)

